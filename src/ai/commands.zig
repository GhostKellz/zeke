// AI Commands - AI-powered code assistance using gathered context

const std = @import("std");
const gatherer = @import("../context/gatherer.zig");
const Index = @import("../index/index.zig").Index;
const lsp = @import("../lsp/lsp.zig");

/// AI command types
pub const CommandType = enum {
    explain,
    suggest,
    fix,
    refactor,
    document,
    test,
};

/// AI command request
pub const CommandRequest = struct {
    command_type: CommandType,
    file_path: ?[]const u8,
    line: ?u32,
    column: ?u32,
    selection: ?[]const u8,
    prompt: []const u8,
};

/// AI command response
pub const CommandResponse = struct {
    success: bool,
    content: []const u8,
    context_used: []const u8,
    allocator: std.mem.Allocator,

    pub fn deinit(self: *CommandResponse) void {
        self.allocator.free(self.content);
        self.allocator.free(self.context_used);
    }
};

/// AI Command Handler - Prepares context and formats prompts for AI
pub const CommandHandler = struct {
    allocator: std.mem.Allocator,
    context_gatherer: gatherer.ContextGatherer,

    pub fn init(
        allocator: std.mem.Allocator,
        index: *Index,
        lsp_manager: ?*lsp.LspManager,
    ) CommandHandler {
        return .{
            .allocator = allocator,
            .context_gatherer = gatherer.ContextGatherer.init(allocator, index, lsp_manager),
        };
    }

    /// Execute an AI command
    pub fn execute(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        return switch (request.command_type) {
            .explain => try self.handleExplain(request),
            .suggest => try self.handleSuggest(request),
            .fix => try self.handleFix(request),
            .refactor => try self.handleRefactor(request),
            .document => try self.handleDocument(request),
            .test => try self.handleTest(request),
        };
    }

    /// Explain code at a specific location
    fn handleExplain(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        // Gather context around the position
        var context = if (request.file_path != null and request.line != null and request.column != null)
            try self.context_gatherer.gatherForPosition(
                request.file_path.?,
                request.line.?,
                request.column.?,
            )
        else
            try self.context_gatherer.gatherForTask(request.prompt, request.file_path);

        defer context.deinit();

        // Build explanation prompt
        var prompt_builder = std.ArrayList(u8).empty;
        defer prompt_builder.deinit(self.allocator);

        try prompt_builder.appendSlice(self.allocator, "# Task: Explain Code\n\n");

        if (request.file_path) |path| {
            try prompt_builder.writer().print("File: {s}\n", .{path});
        }

        if (request.line) |line| {
            try prompt_builder.writer().print("Line: {}\n", .{line});
        }

        try prompt_builder.appendSlice(self.allocator, "\n## Context:\n\n");

        // Add context items
        for (context.items.items) |item| {
            try prompt_builder.writer().print("### {s} - {s}\n", .{
                @tagName(item.source),
                item.file_path,
            });
            try prompt_builder.writer().print("```\n{s}\n```\n\n", .{item.content});
        }

        // Add tree view if available
        if (context.tree_view) |tree_view| {
            try prompt_builder.appendSlice(self.allocator, "### Project Structure:\n");
            try prompt_builder.writer().print("```\n{s}\n```\n\n", .{tree_view});
        }

        try prompt_builder.appendSlice(self.allocator, "\n## User Question:\n");
        try prompt_builder.writer().print("{s}\n\n", .{request.prompt});

        try prompt_builder.appendSlice(self.allocator,
            \\Please explain the code in detail, focusing on:
            \\1. What the code does
            \\2. How it works
            \\3. Key concepts and patterns used
            \\4. Any potential issues or improvements
            \\
        );

        const prompt = try prompt_builder.toOwnedSlice(self.allocator);
        defer self.allocator.free(prompt);

        // In a real implementation, this would call an AI API
        // For now, return a placeholder response
        const response_content = try std.fmt.allocPrint(
            self.allocator,
            "[Explanation would be generated by AI]\n\nContext gathered: {} items, {} chars total",
            .{ context.items.items.len, context.total_chars },
        );

        const context_summary = try std.fmt.allocPrint(
            self.allocator,
            "Used {} context items ({} chars)",
            .{ context.items.items.len, context.total_chars },
        );

        return .{
            .success = true,
            .content = response_content,
            .context_used = context_summary,
            .allocator = self.allocator,
        };
    }

    /// Suggest improvements for code
    fn handleSuggest(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        var context = try self.context_gatherer.gatherForTask(
            request.prompt,
            request.file_path,
        );
        defer context.deinit();

        var prompt_builder = std.ArrayList(u8).empty;
        defer prompt_builder.deinit(self.allocator);

        try prompt_builder.appendSlice(self.allocator, "# Task: Suggest Improvements\n\n");

        if (request.file_path) |path| {
            try prompt_builder.writer().print("File: {s}\n\n", .{path});
        }

        try prompt_builder.appendSlice(self.allocator, "## Current Code:\n\n");

        // Add relevant context
        for (context.items.items) |item| {
            if (item.source == .file_content or item.source == .index) {
                try prompt_builder.writer().print("```\n{s}\n```\n\n", .{item.content});
            }
        }

        try prompt_builder.appendSlice(self.allocator, "\n## Request:\n");
        try prompt_builder.writer().print("{s}\n\n", .{request.prompt});

        try prompt_builder.appendSlice(self.allocator,
            \\Please suggest specific improvements, considering:
            \\1. Code quality and best practices
            \\2. Performance optimizations
            \\3. Error handling
            \\4. Readability and maintainability
            \\5. Testing opportunities
            \\
        );

        const response_content = try std.fmt.allocPrint(
            self.allocator,
            "[Suggestions would be generated by AI]\n\nAnalyzed {} context items",
            .{context.items.items.len},
        );

        const context_summary = try std.fmt.allocPrint(
            self.allocator,
            "Analyzed {} files with {} relevant symbols",
            .{ context.items.items.len, context.total_chars },
        );

        return .{
            .success = true,
            .content = response_content,
            .context_used = context_summary,
            .allocator = self.allocator,
        };
    }

    /// Fix code issues
    fn handleFix(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        // Gather context with emphasis on diagnostics
        var context = if (request.file_path) |path|
            try self.context_gatherer.gatherForTask(request.prompt, path)
        else
            try self.context_gatherer.gatherForTask(request.prompt, null);

        defer context.deinit();

        var prompt_builder = std.ArrayList(u8).empty;
        defer prompt_builder.deinit(self.allocator);

        try prompt_builder.appendSlice(self.allocator, "# Task: Fix Code Issues\n\n");

        // Add diagnostics context (high priority)
        var has_diagnostics = false;
        for (context.items.items) |item| {
            if (item.source == .lsp) {
                if (!has_diagnostics) {
                    try prompt_builder.appendSlice(self.allocator, "## Diagnostics:\n\n");
                    has_diagnostics = true;
                }
                try prompt_builder.writer().print("```\n{s}\n```\n\n", .{item.content});
            }
        }

        try prompt_builder.appendSlice(self.allocator, "## Code:\n\n");
        for (context.items.items) |item| {
            if (item.source == .file_content) {
                try prompt_builder.writer().print("```\n{s}\n```\n\n", .{item.content});
                break; // Only include the main file
            }
        }

        try prompt_builder.appendSlice(self.allocator, "\n## Request:\n");
        try prompt_builder.writer().print("{s}\n\n", .{request.prompt});

        try prompt_builder.appendSlice(self.allocator,
            \\Please provide fixes for the issues, including:
            \\1. Explanation of what's wrong
            \\2. Corrected code
            \\3. Why the fix works
            \\
        );

        const response_content = try std.fmt.allocPrint(
            self.allocator,
            "[Fix would be generated by AI]\n\nGathered context with {} items",
            .{context.items.items.len},
        );

        const context_summary = try std.fmt.allocPrint(
            self.allocator,
            "Fixed issues in {s}",
            .{request.file_path orelse "unknown file"},
        );

        return .{
            .success = true,
            .content = response_content,
            .context_used = context_summary,
            .allocator = self.allocator,
        };
    }

    /// Refactor code
    fn handleRefactor(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        return try self.handleSuggest(request); // Similar logic to suggest
    }

    /// Generate documentation
    fn handleDocument(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        var context = try self.context_gatherer.gatherForTask(
            request.prompt,
            request.file_path,
        );
        defer context.deinit();

        const response_content = try std.fmt.allocPrint(
            self.allocator,
            "[Documentation would be generated by AI]\n\nDocumenting code from {} sources",
            .{context.items.items.len},
        );

        const context_summary = try std.fmt.allocPrint(
            self.allocator,
            "Generated docs for {s}",
            .{request.file_path orelse "unknown file"},
        );

        return .{
            .success = true,
            .content = response_content,
            .context_used = context_summary,
            .allocator = self.allocator,
        };
    }

    /// Generate tests
    fn handleTest(self: *CommandHandler, request: CommandRequest) !CommandResponse {
        var context = try self.context_gatherer.gatherForTask(
            request.prompt,
            request.file_path,
        );
        defer context.deinit();

        const response_content = try std.fmt.allocPrint(
            self.allocator,
            "[Test cases would be generated by AI]\n\nAnalyzed {} code sections",
            .{context.items.items.len},
        );

        const context_summary = try std.fmt.allocPrint(
            self.allocator,
            "Generated tests for {s}",
            .{request.file_path orelse "unknown file"},
        );

        return .{
            .success = true,
            .content = response_content,
            .context_used = context_summary,
            .allocator = self.allocator,
        };
    }
};

// Tests
test "CommandHandler: explain command" {
    const allocator = std.testing.allocator;

    var index = try Index.init(allocator, "/tmp/test");
    defer index.deinit();

    var handler = CommandHandler.init(allocator, &index, null);

    const request = CommandRequest{
        .command_type = .explain,
        .file_path = null,
        .line = null,
        .column = null,
        .selection = null,
        .prompt = "Explain this function",
    };

    var response = try handler.execute(request);
    defer response.deinit();

    try std.testing.expect(response.success);
}
